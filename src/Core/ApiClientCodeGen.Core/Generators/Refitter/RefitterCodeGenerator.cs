using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Text.Json;
using Rapicgen.Core.Generators;
using Rapicgen.Core.Installer;
using Rapicgen.Core.Logging;
using Rapicgen.Core.Options.Refitter;

namespace Rapicgen.Core.Generators.Refitter;

public class RefitterCodeGenerator : ICodeGenerator
{
    private readonly string inputFile;
    private readonly string defaultNamespace;
    private readonly IRefitterOptions options;
    private readonly IProcessLauncher processLauncher;
    private readonly IDependencyInstaller dependencyInstaller;

    private const string Command = "refitter";

    public RefitterCodeGenerator(
        string swaggerFile,
        string defaultNamespace,
        IProcessLauncher processLauncher,
        IDependencyInstaller dependencyInstaller,
        IRefitterOptions options)
    {
        this.inputFile = swaggerFile;
        this.defaultNamespace = defaultNamespace;
        this.processLauncher = processLauncher;
        this.dependencyInstaller = dependencyInstaller;
        this.options = options;
    }

    [SuppressMessage(
        "Usage",
        "VSTHRD002:Avoid problematic synchronous waits",
        Justification = "This is run from a Visual Studio CustomTool")]
    public string GenerateCode(IProgressReporter? pGenerateProgress)
    {
        pGenerateProgress?.Progress(10);
        dependencyInstaller.InstallRefitter();

        pGenerateProgress?.Progress(30);

        if (inputFile.EndsWith(".refitter"))
        {
            return GenerateFromSettingsFile(pGenerateProgress);
        }
        else
        {
            return GenerateFromSwaggerFile(pGenerateProgress);
        }
    }

    private string GenerateFromSettingsFile(IProgressReporter? pGenerateProgress)
    {
        var settingsContent = File.ReadAllText(inputFile);
        var settings = JsonSerializer.Deserialize<RefitterSettings>(settingsContent, new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        });

        pGenerateProgress?.Progress(40);

        var arguments = $"--settings-file \"{inputFile}\"";
        var workingDirectory = Path.GetDirectoryName(inputFile);

        using var context = new DependencyContext("Refitter", $"{Command} {arguments}");
        processLauncher.Start(Command, arguments, workingDirectory);
        context.Succeeded();

        pGenerateProgress?.Progress(80);

        // For settings files, the output is written directly to the specified file
        // We return empty string for multi-file generation or read the output file for single file
        if (settings?.GenerateMultipleFiles == true)
        {
            return string.Empty;
        }

        // Try to read the generated output file
        var outputFilePath = GetOutputFilePath(settings, workingDirectory);
        if (File.Exists(outputFilePath))
        {
            var generatedCode = File.ReadAllText(outputFilePath);
            pGenerateProgress?.Progress(100);
            return GeneratedCode.PrefixAutogeneratedCodeHeader(generatedCode, "Refitter", "v1.6.2");
        }

        pGenerateProgress?.Progress(100);
        return GeneratedCode.PrefixAutogeneratedCodeHeader(string.Empty, "Refitter", "v1.6.2");
    }

    private string GenerateFromSwaggerFile(IProgressReporter? pGenerateProgress)
    {
        var fileInfo = new FileInfo(inputFile);
        var workingDirectory = fileInfo.Directory!.FullName;
        
        // Check if there's a corresponding .refitter file
        var refitterFile = Path.Combine(workingDirectory, fileInfo.Name.Replace(fileInfo.Extension, ".refitter"));
        if (File.Exists(refitterFile))
        {
            var newGenerator = new RefitterCodeGenerator(refitterFile, defaultNamespace, processLauncher, dependencyInstaller, options);
            return newGenerator.GenerateCode(pGenerateProgress);
        }
        else
        {
            // Create a .refitter settings file based on the current options
            var settings = new RefitterSettings
            {
                OpenApiPath = inputFile,
                Namespace = defaultNamespace,
                AddAutoGeneratedHeader = options.AddAutoGeneratedHeader,
                GenerateContracts = options.GenerateContracts,
                GenerateXmlDocCodeComments = options.GenerateXmlDocCodeComments,
                ReturnIApiResponse = options.ReturnIApiResponse,
                UseCancellationTokens = options.UseCancellationTokens,
                GenerateOperationHeaders = options.GenerateHeaderParameters,
                GenerateMultipleFiles = options.GenerateMultipleFiles
            };

            File.WriteAllText(refitterFile, SerializeSettings(settings));
        }

        pGenerateProgress?.Progress(40);

        // Generate directly from swagger file using CLI options
        var outputPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString() + ".cs");
        
        var arguments = BuildRefitterArguments(inputFile, outputPath);

        using var context = new DependencyContext("Refitter", $"{Command} {arguments}");
        processLauncher.Start(Command, arguments, workingDirectory);
        context.Succeeded();

        pGenerateProgress?.Progress(80);

        string generatedCode = string.Empty;
        if (File.Exists(outputPath))
        {
            generatedCode = File.ReadAllText(outputPath);
            File.Delete(outputPath); // Clean up temp file
        }

        pGenerateProgress?.Progress(100);
        return GeneratedCode.PrefixAutogeneratedCodeHeader(generatedCode, "Refitter", "v1.6.2");
    }

    private string BuildRefitterArguments(string inputFile, string outputPath)
    {
        var args = $"\"{inputFile}\" --output \"{outputPath}\"";
        
        if (!string.IsNullOrEmpty(defaultNamespace))
        {
            args += $" --namespace \"{defaultNamespace}\"";
        }

        if (!options.GenerateContracts)
        {
            args += " --interface-only";
        }

        if (!options.GenerateXmlDocCodeComments)
        {
            args += " --no-xml-doc-comments";
        }

        if (options.ReturnIApiResponse)
        {
            args += " --use-api-response";
        }

        if (options.GenerateInternalTypes)
        {
            args += " --internal";
        }

        if (options.UseCancellationTokens)
        {
            args += " --cancellation-tokens";
        }

        if (!options.GenerateHeaderParameters)
        {
            args += " --no-operation-headers";
        }

        if (!options.AddAutoGeneratedHeader)
        {
            args += " --no-auto-generated-header";
        }

        return args;
    }

    private static string GetOutputFilePath(RefitterSettings? settings, string? workingDirectory)
    {
        if (settings == null || workingDirectory == null)
            return Path.Combine(workingDirectory ?? "", "Output.cs");

        var outputFolder = settings.OutputFolder ?? "";
        var outputFilename = settings.OutputFilename ?? "Output.cs";
        
        if (Path.IsPathRooted(outputFolder))
        {
            return Path.Combine(outputFolder, outputFilename);
        }
        
        return Path.Combine(workingDirectory, outputFolder, outputFilename);
    }

    private static string SerializeSettings(RefitterSettings settings)
    {
        return JsonSerializer.Serialize(
            settings,
            new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = true
            });
    }

    // Minimal representation of Refitter settings for JSON deserialization
    private class RefitterSettings
    {
        public string? OpenApiPath { get; set; }
        public string? Namespace { get; set; }
        public string? OutputFolder { get; set; }
        public string? OutputFilename { get; set; }
        public bool GenerateMultipleFiles { get; set; }
        public bool AddAutoGeneratedHeader { get; set; }
        public bool GenerateContracts { get; set; }
        public bool GenerateXmlDocCodeComments { get; set; }
        public bool ReturnIApiResponse { get; set; }
        public bool UseCancellationTokens { get; set; }
        public bool GenerateOperationHeaders { get; set; }
    }
}
