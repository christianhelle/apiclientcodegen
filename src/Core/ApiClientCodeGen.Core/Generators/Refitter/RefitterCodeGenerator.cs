using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using Rapicgen.Core.Installer;
using Rapicgen.Core.Logging;
using Rapicgen.Core.Options.Refitter;

namespace Rapicgen.Core.Generators.Refitter;

public class RefitterCodeGenerator : ICodeGenerator
{
    private readonly string inputFile;
    private readonly string defaultNamespace;
    private readonly IRefitterOptions options;
    private readonly IProcessLauncher processLauncher;
    private readonly IDependencyInstaller dependencyInstaller;

    private const string Command = "refitter";

    public RefitterCodeGenerator(
        string swaggerFile,
        string defaultNamespace,
        IProcessLauncher processLauncher,
        IDependencyInstaller dependencyInstaller,
        IRefitterOptions options)
    {
        this.inputFile = swaggerFile;
        this.defaultNamespace = defaultNamespace;
        this.processLauncher = processLauncher;
        this.dependencyInstaller = dependencyInstaller;
        this.options = options;
    }

    [SuppressMessage(
        "Usage",
        "VSTHRD002:Avoid problematic synchronous waits",
        Justification = "This is run from a Visual Studio CustomTool")]
    public string GenerateCode(IProgressReporter? pGenerateProgress)
    {
        pGenerateProgress?.Progress(10);
        dependencyInstaller.InstallRefitter();

        pGenerateProgress?.Progress(30);

        if (inputFile.EndsWith(".refitter"))
        {
            return GenerateFromSettingsFile(pGenerateProgress);
        }
        else
        {
            return GenerateFromSwaggerFile(pGenerateProgress);
        }
    }

    private string GenerateFromSettingsFile(IProgressReporter? pGenerateProgress)
    {
        var settingsContent = File.ReadAllText(inputFile);
        var settings = DeserializeSettings(settingsContent);

        pGenerateProgress?.Progress(40);

        var arguments = $"--settings-file \"{inputFile}\" --simple-output";
        var workingDirectory = Path.GetDirectoryName(inputFile);

        using var context = new DependencyContext("Refitter", $"{Command} {arguments}");
        processLauncher.Start(Command, arguments, workingDirectory);
        context.Succeeded();

        pGenerateProgress?.Progress(80);

        // For settings files, the output is written directly to the specified file
        // We return empty string for multi-file generation or read the output file for single file
        if (settings?.GenerateMultipleFiles == true)
        {
            return string.Empty;
        }

        // Try to read the generated output file
        var outputFilePath = GetOutputFilePath(settings, workingDirectory);
        if (File.Exists(outputFilePath))
        {
            var generatedCode = File.ReadAllText(outputFilePath);
            pGenerateProgress?.Progress(100);
            return GeneratedCode.PrefixAutogeneratedCodeHeader(generatedCode, "Refitter", "v1.6.5");
        }

        pGenerateProgress?.Progress(100);
        return GeneratedCode.PrefixAutogeneratedCodeHeader(string.Empty, "Refitter", "v1.6.5");
    }

    private string GenerateFromSwaggerFile(IProgressReporter? pGenerateProgress)
    {
        var fileInfo = new FileInfo(inputFile);
        var workingDirectory = fileInfo.Directory!.FullName;
        
        var refitterFile = Path.Combine(workingDirectory, fileInfo.Name.Replace(fileInfo.Extension, ".refitter"));
        if (File.Exists(refitterFile))
        {
            var newGenerator = new RefitterCodeGenerator(refitterFile, defaultNamespace, processLauncher, dependencyInstaller, options);
            return newGenerator.GenerateCode(pGenerateProgress);
        }
        else
        {
            var settings = new RefitterSettings
            {
                OpenApiPath = inputFile,
                OutputFilename = Path.ChangeExtension(inputFile, ".cs"),
                Namespace = defaultNamespace,
                AddAutoGeneratedHeader = options.AddAutoGeneratedHeader,
                GenerateContracts = options.GenerateContracts,
                GenerateXmlDocCodeComments = options.GenerateXmlDocCodeComments,
                ReturnIApiResponse = options.ReturnIApiResponse,
                UseCancellationTokens = options.UseCancellationTokens,
                GenerateOperationHeaders = options.GenerateHeaderParameters,
                GenerateMultipleFiles = options.GenerateMultipleFiles
            };

            File.WriteAllText(refitterFile, SerializeSettings(settings));
        }

        pGenerateProgress?.Progress(40);

        // Generate directly from swagger file using CLI options
        var outputPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString() + ".cs");
        
        var arguments = BuildRefitterArguments(inputFile, outputPath);

        using var context = new DependencyContext("Refitter", $"{Command} {arguments}");
        processLauncher.Start(Command, arguments, workingDirectory);
        context.Succeeded();

        pGenerateProgress?.Progress(80);

        string generatedCode = string.Empty;
        if (File.Exists(outputPath))
        {
            generatedCode = File.ReadAllText(outputPath);
            File.Delete(outputPath); // Clean up temp file
        }

        pGenerateProgress?.Progress(100);
        return GeneratedCode.PrefixAutogeneratedCodeHeader(generatedCode, "Refitter", "v1.6.5");
    }

    private string BuildRefitterArguments(string inputFile, string outputPath)
    {
        var args = $"\"{inputFile}\" --output \"{outputPath}\" --simple-output";
        
        if (!string.IsNullOrEmpty(defaultNamespace))
        {
            args += $" --namespace \"{defaultNamespace}\"";
        }

        if (!options.GenerateContracts)
        {
            args += " --interface-only";
        }

        if (!options.GenerateXmlDocCodeComments)
        {
            args += " --no-xml-doc-comments";
        }

        if (options.ReturnIApiResponse)
        {
            args += " --use-api-response";
        }

        if (options.GenerateInternalTypes)
        {
            args += " --internal";
        }

        if (options.UseCancellationTokens)
        {
            args += " --cancellation-tokens";
        }

        if (!options.GenerateHeaderParameters)
        {
            args += " --no-operation-headers";
        }

        if (!options.AddAutoGeneratedHeader)
        {
            args += " --no-auto-generated-header";
        }

        return args;
    }

    private static string GetOutputFilePath(RefitterSettings? settings, string? workingDirectory)
    {
        if (settings == null || workingDirectory == null)
            return Path.Combine(workingDirectory ?? "", "Output.cs");

        var outputFolder = settings.OutputFolder ?? "";
        var outputFilename = settings.OutputFilename ?? "Output.cs";
        
        if (Path.IsPathRooted(outputFolder))
        {
            return Path.Combine(outputFolder, outputFilename);
        }
        
        return Path.Combine(workingDirectory, outputFolder, outputFilename);
    }

    private static RefitterSettings DeserializeSettings(string json)
    {
        var settings = new RefitterSettings();
        
        // Simple JSON parser - extract only the properties we need
        var lines = json.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
        
        foreach (var line in lines)
        {
            var trimmed = line.Trim().TrimEnd(',');
            
            if (trimmed.Contains("\"generateMultipleFiles\""))
            {
                settings.GenerateMultipleFiles = ExtractBoolValue(trimmed);
            }
            else if (trimmed.Contains("\"outputFolder\""))
            {
                settings.OutputFolder = ExtractStringValue(trimmed);
            }
            else if (trimmed.Contains("\"outputFilename\""))
            {
                settings.OutputFilename = ExtractStringValue(trimmed);
            }
        }
        
        return settings;
    }
    
    private static bool ExtractBoolValue(string line)
    {
        return line.Contains("true", StringComparison.OrdinalIgnoreCase);
    }
    
    private static string? ExtractStringValue(string line)
    {
        var colonIndex = line.IndexOf(':');
        if (colonIndex < 0) return null;
        
        var valueStart = line.IndexOf('"', colonIndex + 1);
        if (valueStart < 0) return null;
        
        var valueEnd = line.IndexOf('"', valueStart + 1);
        if (valueEnd < 0) return null;
        
        return line.Substring(valueStart + 1, valueEnd - valueStart - 1);
    }

    private static string SerializeSettings(RefitterSettings settings)
    {
        var json = new System.Text.StringBuilder();
        json.AppendLine("{");
        
        if (!string.IsNullOrEmpty(settings.OpenApiPath))
        {
            json.AppendLine($"  \"openApiPath\": \"{EscapeJsonString(settings.OpenApiPath)}\",");
        }
        
        if (!string.IsNullOrEmpty(settings.Namespace))
        {
            json.AppendLine($"  \"namespace\": \"{EscapeJsonString(settings.Namespace)}\",");
        }
        
        if (!string.IsNullOrEmpty(settings.OutputFolder))
        {
            json.AppendLine($"  \"outputFolder\": \"{EscapeJsonString(settings.OutputFolder)}\",");
        }
        
        if (!string.IsNullOrEmpty(settings.OutputFilename))
        {
            json.AppendLine($"  \"outputFilename\": \"{EscapeJsonString(settings.OutputFilename)}\",");
        }
        
        json.AppendLine($"  \"generateMultipleFiles\": {settings.GenerateMultipleFiles.ToString().ToLowerInvariant()},");
        json.AppendLine($"  \"addAutoGeneratedHeader\": {settings.AddAutoGeneratedHeader.ToString().ToLowerInvariant()},");
        json.AppendLine($"  \"generateContracts\": {settings.GenerateContracts.ToString().ToLowerInvariant()},");
        json.AppendLine($"  \"generateXmlDocCodeComments\": {settings.GenerateXmlDocCodeComments.ToString().ToLowerInvariant()},");
        json.AppendLine($"  \"returnIApiResponse\": {settings.ReturnIApiResponse.ToString().ToLowerInvariant()},");
        json.AppendLine($"  \"useCancellationTokens\": {settings.UseCancellationTokens.ToString().ToLowerInvariant()},");
        json.AppendLine($"  \"generateOperationHeaders\": {settings.GenerateOperationHeaders.ToString().ToLowerInvariant()}");
        json.AppendLine("}");
        
        return json.ToString();
    }
    
    private static string EscapeJsonString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }

    // Minimal representation of Refitter settings for JSON deserialization
    private class RefitterSettings
    {
        public string? OpenApiPath { get; set; }
        public string? Namespace { get; set; }
        public string? OutputFolder { get; set; }
        public string? OutputFilename { get; set; }
        public bool GenerateMultipleFiles { get; set; }
        public bool AddAutoGeneratedHeader { get; set; }
        public bool GenerateContracts { get; set; }
        public bool GenerateXmlDocCodeComments { get; set; }
        public bool ReturnIApiResponse { get; set; }
        public bool UseCancellationTokens { get; set; }
        public bool GenerateOperationHeaders { get; set; }
    }
}
